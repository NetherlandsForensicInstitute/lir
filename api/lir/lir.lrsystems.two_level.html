

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lir.lrsystems.two_level &mdash; LiR - Likelihood Ratio Toolkit  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../../_static/thebelab-helper.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="lir.config" href="lir.config.html" />
    <link rel="prev" title="lir.lrsystems.binary_lrsystem" href="lir.lrsystems.binary_lrsystem.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            LiR - Likelihood Ratio Toolkit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides.html">Guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../lrsystem_yaml.html">LR System selection helper</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../lrsystem_yaml.html#specific-source-system">Specific source system</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lrsystem_yaml.html#pre-scored-common-source-system">Pre-scored common source system</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lrsystem_yaml.html#common-source-system">Common source system</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api-overview.html">Overview of the Python API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api-overview.html#data-classes">Data classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api-overview.html#data-strategies">Data strategies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api-overview.html#lr-systems">LR systems</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../lrsystem-assessment.html">Assessing LR system performance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../lrsystem-assessment.html#metrics">Metrics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lrsystem-assessment.html#visualizations">Visualizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lrsystem-assessment.html#neutral-llrs">Neutral LLRs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lrsystem-assessment.html#well-calibrated-llrs">Well-calibrated LLRs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../lrsystem-assessment.html#badly-calibrated-data">Badly calibrated data</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">Registry reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference.html#experiment-components">Experiment components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference.html#experiment-strategies">Experiment strategies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference.html#data-strategies">Data strategies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference.html#data-providers">Data providers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference.html#metrics">Metrics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference.html#output">Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference.html#hyperparameters">Hyperparameters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference.html#lr-system-components">LR system components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference.html#lr-system-architecture">LR system architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference.html#lr-system-modules">LR system modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference.html#pairing-methods">Pairing methods</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="lir.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lir</span></code></a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="lir.html#subpackages">Subpackages</a></li>
<li class="toctree-l3"><a class="reference internal" href="lir.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="lir.html#package-contents">Package Contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">LiR - Likelihood Ratio Toolkit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="lir.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lir</span></code></a></li>
          <li class="breadcrumb-item"><a href="lir.lrsystems.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lir.lrsystems</span></code></a></li>
      <li class="breadcrumb-item active"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lir.lrsystems.two_level</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/api/lir/lir.lrsystems.two_level.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-lir.lrsystems.two_level">
<span id="lir-lrsystems-two-level"></span><h1><a class="reference internal" href="#module-lir.lrsystems.two_level" title="lir.lrsystems.two_level"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lir.lrsystems.two_level</span></code></a><a class="headerlink" href="#module-lir.lrsystems.two_level" title="Link to this heading"></a></h1>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading"></a></h2>
<section id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h3>
<table class="autosummary longtable docutils align-left">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE" title="lir.lrsystems.two_level.TwoLevelModelNormalKDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TwoLevelModelNormalKDE</span></code></a></p></td>
<td><p>Implement two-level model as outlined by Bolck et al.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lir.lrsystems.two_level.TwoLevelSystem" title="lir.lrsystems.two_level.TwoLevelSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TwoLevelSystem</span></code></a></p></td>
<td><p>Implement two level model, common-source feature-based LR system architecture.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h3>
<table class="autosummary longtable docutils align-left">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lir.lrsystems.two_level._split_pairs" title="lir.lrsystems.two_level._split_pairs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_split_pairs</span></code></a></p></td>
<td><p>Split the input array along the second dimension at position <code class="docutils literal notranslate"><span class="pre">n_trace</span></code>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="api">
<h3>API<a class="headerlink" href="#api" title="Link to this heading"></a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">lir.lrsystems.two_level.</span></span><span class="sig-name descname"><span class="pre">TwoLevelModelNormalKDE</span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE" title="Link to this definition"></a></dt>
<dd><p>Implement two-level model as outlined by Bolck et al.</p>
<p>An implementation of the two-level model as outlined in FSI191(2009)42 by Bolck et al. “Different likelihood
ratio approaches to evaluate the strength of evidence of MDMA tablet comparisons”.</p>
<p>Model description:</p>
<p>Definitions
X_ij = vector, measurement of reference j, ith repetition, with i=1..n
Y_kl = vector, measurement of trace l, kth repetition, with k=1..m</p>
<p>Model:</p>
<p>First level of variance:
X_ij ~ N(theta_j, sigma_within)
Y_kl ~ N(theta_k, sigma_within)
where theta_j is the true but unknown mean of the reference and theta_k the true but unknown mean of the trace.
sigma_within is assumed equal for trace and reference (and for repeated measurements of some background data)</p>
<p>Second level of variance:
theta_j ~ theta_k ~ KDE(means background database, h)
with h the kernel bandwidth.</p>
<p>H1: theta_j = theta_k
H2: theta_j independent of theta_k</p>
<p>Numerator LR = Integral_theta N(X_Mean|theta, sigma_within, n) * N(Y_mean|theta, sigma_within, m) *             KDE(theta|means background database, h)
Denominator LR = Integral_theta N(X_Mean|theta, sigma_within, n) * KDE(theta|means background database, h) *             Integral_theta N(Y_Mean|theta, sigma_within, m) * KDE(theta|means background database, h)</p>
<p>In Bolck et al. in the appendix one finds a closed-form solution for the evaluation of these integrals.</p>
<p>sigma_within and h (and other parameters) are estimated from repeated measurements of background data.</p>
<p class="rubric">Initialization</p>
<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE.fit_on_unpaired_instances">
<span class="sig-name descname"><span class="pre">fit_on_unpaired_instances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE" title="lir.lrsystems.two_level.TwoLevelModelNormalKDE"><span class="pre">lir.lrsystems.two_level.TwoLevelModelNormalKDE</span></a></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE.fit_on_unpaired_instances" title="Link to this definition"></a></dt>
<dd><p>Fit the model on unpaired instances.</p>
<p>X np.ndarray of measurements, rows are sources/repetitions, columns are features
y np 1d-array of labels. For each source a unique identifier (label). Repetitions get the same label.</p>
<p>Construct the necessary matrices/scores/etc based on test data (X) so that we can predict a score later on.
Store any calculated parameters in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_ref</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE.transform" title="Link to this definition"></a></dt>
<dd><p>Transform the input data using the fitted model.</p>
<p>Predict odds scores, making use of the parameters constructed during <code class="docutils literal notranslate"><span class="pre">self.fit()</span></code> (which should
now be stored in <code class="docutils literal notranslate"><span class="pre">self</span></code>).</p>
<p>X_trace measurements of trace object. np.ndarray of shape (instances, repetitions_trace, features)
X_ref measurements of reference object. np.ndarray of shape (instances, repetitions_ref, features)</p>
<p>returns: odds of same source / different source: one-dimensional np.ndarray with one element per instance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_ref</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE.predict_proba" title="Link to this definition"></a></dt>
<dd><p>Predict probability scores, using the fitted model.</p>
<p>Predict probability scores, making use of the parameters constructed during <code class="docutils literal notranslate"><span class="pre">self.fit()</span></code> (which should
now be stored in <code class="docutils literal notranslate"><span class="pre">self</span></code>).</p>
<p>X_trace measurements of trace object. np.ndarray of shape (instances, repetitions_trace, features)
X_ref measurements of reference object. np.ndarray of shape (instances, repetitions_ref, features)</p>
<p>returns: probabilities for same source and different source: np.ndarray with shape (instances, 2)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_log10_lr_score">
<span class="sig-name descname"><span class="pre">_predict_log10_lr_score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_ref</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_log10_lr_score" title="Link to this definition"></a></dt>
<dd><p>Predict natural log LR scores (ln_LR scores) using the fitted model.</p>
<p>Predict ln_LR scores, making use of the parameters constructed during <code class="docutils literal notranslate"><span class="pre">self.fit()</span></code> (which should
now be stored in <code class="docutils literal notranslate"><span class="pre">self</span></code>).</p>
<p>X_trace measurements of trace object. np.ndarray of shape (instances, repetitions_trace, features)
X_ref measurements of reference object. np.ndarray of shape (instances, repetitions_ref, features)
returns: log10_LR_scores according to the two_level_model in Bolck et al. np.ndarray of shape (instances,)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_n_features">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">_get_n_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_ix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_n_features" title="Link to this definition"></a></dt>
<dd><p>Calculate the number of features in <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_n_sources">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">_get_n_sources</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_n_sources" title="Link to this definition"></a></dt>
<dd><p>Calculate the number of sources in <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>Y np 1d-array of labels. labels from {1, …, n} with n the number of sources. Repetitions get the same label.
returns: number of sources in y (int).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_mean_covariance_within">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">_get_mean_covariance_within</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_mean_covariance_within" title="Link to this definition"></a></dt>
<dd><p>Calculates a matrix of mean covariances within each of the sources.</p>
<p>X np.array of measurements, rows are sources/repetitions, columns are features
y np 1d-array of labels. labels from {1, …, n} with n the number of sources. Repetitions get the same label.
returns: mean within covariance matrix, np.array.</p>
<p>This function calculates a matrix of mean covariances within each of the sources, it does so by grouping the
data per source, calculating the covariance matrices per source and then taking the mean per feature.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_means_per_source">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">_get_means_per_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_means_per_source" title="Link to this definition"></a></dt>
<dd><p>Provide numpy array of means per source.</p>
<p>X np.array of measurements, rows are sources/repetitions, columns are features
y np 1d-array of labels. For each source a unique identifier (label). Repetitions get the same label.
returns: means per source in a np.array matrix of size: number of sources * number of features.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_kernel_bandwidth_squared">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">_get_kernel_bandwidth_squared</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_sources</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_features_train</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_kernel_bandwidth_squared" title="Link to this definition"></a></dt>
<dd><p>Calculate kernel bandwidth and return it.</p>
<p>Reference: ‘Density estimation for statistics and data analysis’, B.W. Silverman,
page 86 formula 4.14 with A(K) the second row in the table on page 87.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_between_covariance">
<span class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></span><span class="sig-name descname"><span class="pre">_get_between_covariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean_within_covars</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._get_between_covariance" title="Link to this definition"></a></dt>
<dd><p>Calculate and return the between covariance.</p>
<p>X np.array of measurements, rows are objects, columns are variables
y np 1d-array of labels. labels from {1, …, n} with n the number of objects. Repetitions get the same label.
returns: estimated covariance of true mean of the features between sources in the population in a np.array
square matrix with number of features^2 as dimension.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_covariances_trace_ref">
<span class="sig-name descname"><span class="pre">_predict_covariances_trace_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_ref</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_covariances_trace_ref" title="Link to this definition"></a></dt>
<dd><p>Calculate and return covariances of trace references.</p>
<p>X_tr np.array of measurements of trace object, rows are repetitions, columns are features
X_ref np.array of measurements of reference object, rows are repetitions, columns features
returns: covariance matrices of the trace and reference data and their respective inverses needed for
LR calculation;
covars_trace is the covariance matrix for the trace data given a KDE background mean (U_h0),
covars_trace_update is the covariance matrix for the trace mean with a bayesian update of reference mean
given a KDE background mean (U_hn),
covars_ref is the covariance matrix for the reference data given a KDE background mean (U_hx),
covars_trace_inv is the inverse of covars_trace,
covars_trace_update_inv is the inverse of covars_trace_update,
covars_ref_inv is the inverse of covars_ref.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_updated_ref_mean">
<span class="sig-name descname"><span class="pre">_predict_updated_ref_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_ref</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covars_ref_inv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_updated_ref_mean" title="Link to this definition"></a></dt>
<dd><p>Calculate and return bayesian update of reference mean given KDE background means.</p>
<p>X_ref np.array of measurements of reference object, rows are repetitions, columns features
returns: updated_ref_mean, bayesian update of reference mean given KDE background means.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_ln_num">
<span class="sig-name descname"><span class="pre">_predict_ln_num</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_ref</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covars_ref_inv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covars_trace_update_inv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">updated_ref_mean</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.floating</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_ln_num" title="Link to this definition"></a></dt>
<dd><p>Perform calculation to predict natural log of numerator.</p>
<p>See Bolck et al. formula in appendix. The formula consists of three sum_terms (and some other terms).
The numerator sum term is calculated here.
The numerator is based on the product of two Gaussian PDFs.
The first PDF: ref_mean ~ N(background_mean, U_hx).
The second PDF: trace_mean ~ N(updated_ref_mean, U_hn).
In this function log of the PDF is taken (so the exponentiation is left out and the product becomes a sum).</p>
<p>X_trace np.array of measurements of trace object, rows are repetitions, columns are variables
X_ref np.array of measurements of reference object, rows are repetitions, columns are variables
covars_ref_inv, covars_trace_update_inv, np.arrays as calculated by _predict_covariances_trace_ref
updated_ref_mean np.array with same dimensions as X, calculated by _predict_updated_ref_mean
returns: ln_num1, natural log of numerator of the LR-formula in Bolck et al.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_ln_den_term">
<span class="sig-name descname"><span class="pre">_predict_ln_den_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_ref_or_trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covars_inv</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.floating</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_ln_den_term" title="Link to this definition"></a></dt>
<dd><p>Perform calculation and return natural log of a denominator term of the LR-formula.</p>
<p>See Bolck et al. formula in appendix. The formula consists of three sum_terms (and some other terms).
A denominator sum term is calculated here.</p>
<p>X_ref_or_trace np.array of measurements of reference or trace object, rows are repetitions, columns are features
U_inv, np.array with respective covariance matrix as calculated by _predict_covariances_trace_ref
returns: ln_den, natural log of a denominator term of the LR-formula in Bolck et al.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_log10_LR_from_formula_Bolck">
<span class="sig-name descname"><span class="pre">_predict_log10_LR_from_formula_Bolck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">covars_trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covars_trace_update</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ln_num</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.floating</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ln_den_left</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.floating</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ln_den_right</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.floating</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.floating</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelModelNormalKDE._predict_log10_LR_from_formula_Bolck" title="Link to this definition"></a></dt>
<dd><p>Predict 10-base logarithm LR’s from the Bolck formula.</p>
<p>X_trace np.array of measurements of trace object, rows are repetitions, columns are variables
covars_trace, covars_trace_update, np.arrays as calculated by _predict_covariances_trace_ref
ln_num, ln_den_left, ln_den_right: terms in big fraction in Bolck et al, as calculated by _predict_ln_num
and _predict_ln_den_term
returns: log10_LR_score, 10log of LR according to the LR-formula in Bolck et al.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lir.lrsystems.two_level._split_pairs">
<span class="sig-prename descclassname"><span class="pre">lir.lrsystems.two_level.</span></span><span class="sig-name descname"><span class="pre">_split_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pairs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_trace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#lir.lrsystems.two_level._split_pairs" title="Link to this definition"></a></dt>
<dd><p>Split the input array along the second dimension at position <code class="docutils literal notranslate"><span class="pre">n_trace</span></code>.</p>
<dl class="myst field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pairs</strong> – a feature array of dimension: (pairs, instances, features)</p></li>
<li><p><strong>n_trace</strong> – the number of trace instances</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tuple of two arrays of trace features and reference features, both of dimension:
(pairs, instances, features)</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelSystem">
<span class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></span><span class="sig-prename descclassname"><span class="pre">lir.lrsystems.two_level.</span></span><span class="sig-name descname"><span class="pre">TwoLevelSystem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preprocessing_pipeline</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">lir.Transformer</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pairing_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="lir.transform.pairing.html#lir.transform.pairing.PairingMethod" title="lir.transform.pairing.PairingMethod"><span class="pre">lir.transform.pairing.PairingMethod</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">postprocessing_pipeline</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">lir.Transformer</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_trace_instances</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_ref_instances</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelSystem" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="lir.lrsystems.lrsystems.html#lir.lrsystems.lrsystems.LRSystem" title="lir.lrsystems.lrsystems.LRSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lir.lrsystems.lrsystems.LRSystem</span></code></a></p>
<p>Implement two level model, common-source feature-based LR system architecture.</p>
<p>During the training phase, the system calculates statistics on the unpaired instances. On application, it
calculates LRs for same-source and different-source pairs. Each side of the pair may consist of multiple instances.</p>
<p>See also: <code class="docutils literal notranslate"><span class="pre">TwoLevelModelNormalKDE</span></code></p>
<p class="rubric">Initialization</p>
<p>Initialize a new TwoLevelSystem instance.</p>
<dl class="myst field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>preprocessing_pipeline</strong> – a preprocessing pipeline that is applied on unpaired instances</p></li>
<li><p><strong>pairing_function</strong> – a function to generate same-source and different-source pairs</p></li>
<li><p><strong>postprocessing_pipeline</strong> – a postprocessing pipeline that is applied <em>after</em> applying the two level model;
it takes LLRs as input.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelSystem.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="lir.data.models.html#lir.data.models.InstanceData" title="lir.data.models.InstanceData"><span class="pre">lir.data.models.InstanceData</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Self</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelSystem.fit" title="Link to this definition"></a></dt>
<dd><p>Fit the model based on the instance data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lir.lrsystems.two_level.TwoLevelSystem.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instances</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="lir.data.models.html#lir.data.models.InstanceData" title="lir.data.models.InstanceData"><span class="pre">lir.data.models.InstanceData</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">lir.lrsystems.lrsystems.LLRData</span></span></span><a class="headerlink" href="#lir.lrsystems.two_level.TwoLevelSystem.apply" title="Link to this definition"></a></dt>
<dd><p>Apply this LR system on a set of instances and return LLR data.</p>
<p>Applies the two level LR system on a set of instances,
and returns a representation of the calculated LLR data through the <code class="docutils literal notranslate"><span class="pre">LLRData</span></code> tuple.</p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lir.lrsystems.binary_lrsystem.html" class="btn btn-neutral float-left" title="lir.lrsystems.binary_lrsystem" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lir.config.html" class="btn btn-neutral float-right" title="lir.config" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, Netherlands Forensic Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>